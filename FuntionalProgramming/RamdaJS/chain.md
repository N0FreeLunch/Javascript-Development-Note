## chain

> chain maps a function over a list and concatenates the results. chain is also known as flatMap in some libraries.
- 체인은 리스트가 가진 원소 각각에 대해 동일한 하나의 함수를 매핑하고 반환된 각각의 배열의 중첩을 제거한 결과를 반환한다. 일부 라이브러리에서는 `flatMap`으로 알려져 있다.

> Dispatches to the chain method of the second argument, if present, according to the FantasyLand Chain spec.
- 만약 두 번째 인자가 존재한다면 [FantasyLand의 체인 사양](https://github.com/fantasyland/fantasy-land#chain)에 따라, 체인메소드의 두 번째 인자에 대상(리스트 또는 함수)을 전달한다.

> If second argument is a function, chain(f, g)(x) is equivalent to f(g(x), x).
- 두 번째 인자가 함수인 경우에는 `chain(f, g)(x)`는 `f(g(x), x)`와 동등하다.

> Acts as a transducer if a transformer is given in list position.
- 리스트 위치에 만약 변형기가 주어지면 변환기로서 행동한다.

## 설명

- 첫 번째 인자로 하나의 인자를 받아서 리스트 또는 함수를 반환하는 함수를 받는다. 
- 두 번째 인자로 리스트 또는 함수를 받는다.

### 두 번째 인자로 리스트를 받을 때

- 리스트로 받은 원소 각각에 첫 번째 인자로 받은 함수를 적용하고 그 결과에 모든 배열의 중첩을 제거하는 `flatten` 함수를 적용하는 것과 동일한 역할을 한다.
- 배열의 중첩을 제거한다는 것은 `[a,[b,c,[d,e],f,g],h]`를 적용했을 때, `[a,b,c,d,e,f,g,h]`가 되는 것을 뜻한다.

### 두 번째 인자로 함수를 받을 때를 기준으로 두 번째 인자로 리스트를 받을 때를 설명

- 두 번째 인자로 함수를 받을 때 이 함수를 g라고 하고, 첫 번째 인자로 받는 함수를 f라고 할 때, `R.chain(f, g)(x)`의 연산 결과는 `f(g(x), x)`를 한 것과 같다.

- 만약 두 번째 인자로 함수를 받지 않고 배열(`[1,2,3,4,5]`)을 받았다고 하자. 그러면 `f([1,2,3,4,5], x)`가 될 것이다. `g(x)`의 자리에 `[1,2,3,4,5]`가 들어 갔는데 이는 함수 `g(x)`에 해당되므로 어떤 값 `x`를 전달해서 `[1,2,3,4,5]`가 나온 것으로 미지수이다. x는 g라는 함수에 전달했을 때 `[1,2,3,4,5]`를 만드는 값이다.

- 두 번째 인자로 리스트를 받을 때의 `chain(f, list)`와 함수 `g`를 받을 때의 동작을 비교하면 `chain(f, list)`와 `chain(f, g(x))(x)`의 형태가 된다. 이는 chain 함수가 두 번째 인자를 받을 때 함수가 아닌 값(리스트)를 받을 때는, 원래는 `chain(f, g(x))(x)`으로 `chain(f, g(x))` 함수에 `(x)`으로 값을 넘겨 주어 실행하는 것을 `chain(f, list)`으로 함수를 반환하지 않고, `(x)`가 이미 전달된 것으로 보고 결과 값을 반환한다는 의미이다. 곧, 임의의 x에 대해 `g(x) = list`일 때, `chain(f, g(x))(x) = chain(f, list)` <=> `chain(f, list)(x) = chain(f, list)`으로 `x`라는 값이 어떤 값이든 결과 값에 영향을 주는 요소가 아니라는 의미를 내포한다.

- `chain(f, list)(x)`는 `f(list, x)`의 의미와 같고, x는 결과 값에 영향을 주지 않는 요소이므로 (x의 값은 무엇이 되든 상관 없지만 x의 유형 정보는 쓰일 수 있으므로) `f'(list)` 함수를 떠올려 볼 수 있다. (f'는 유형 정보를 담을 수도 있고 유형 정보를 담지 않는다면 f와 동일한 함수가 될 것이다.) `chain(f, list)`는 `f'(list)`으로 표현이 된다.

```js
const duplicate = n => [n, n];
R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
```

- `f`는 `duplicate`이고, `list`는 `[1, 2, 3]`이다. `f'`를 `_duplicate`라고 했을 때, `_duplicate([1,2,3])`가 실행되는 것이다. 그냥 `duplicate([1,2,3])`이라면 `[[1,2,3],[1,2,3]]`이 될 것인데, 유형 정보에 따라 변환을 수행하는 `_duplicate`이므로 `[1,1,2,2,3,3]`을 반환하도록 한다고 이해하면 된다.

- 그러니까 `chain`에서 `f(g(x), x)`가 성립할 때 `g(x)`가 리스트인 경우 리스트 유형 정보를 `chain`에 내포된 리스트 유형 변환에 따른 특별한 연산을 수행한다 정도로 생각하면 된다. 중첩을 푸는 것은 chain 함수의 두 번째 인자로 리스트를 받았을 때만 중첩을 풀며, `chain(f, g)(x)`에서 `g`부분이 함수인 경우는 `f(g(x), x)` 연산을 수행한다고 보면 된다. g가 함수일 때는 배열의 중첩을 푸는 것과 같은 특징을 갖지 않는다.

- 만약에 `chain(f, g)(x)`에서 x에 list를 전달했을 때 `chain(f, list)`와 결과 값이 같으려면 g를 어떻게 정의해야 할까?

```js
const duplicate = n => [n, n];
const g = (v) => { return v; }
R.chain(duplicate, g)([1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
```

- 그런데 최종 연산이 n이 전달되었을 때 `[n, n]`의 형태가 나와야 하는데, 결과가 `[1, 1, 2, 2, 3, 3]`으로 반을 나누어 보아도 `1, 1, 2`과 `2, 3, 3`으로 대칭이 아니다. 함수 g를 어떤 방식으로 만들더라도 위의 결과를 나오게 할 수 있는 g를 정의하는 것은 불가능하다는 것을 알 수 있다. chain 함수는 list에 대해서는 특수한 변환을 수행한다고 보면된다. 2번째 인자로 list를 넣었을 때와 함수를 넣었을 때 완전히 다른 동작을 하는 것으로 보면 된다.

### 체인의 특징

- `chain`이란 함수를 만든 것은 입력과 출력의 형태를 모나드화하여 함수 연산을 체이닝 할 수 있는 형태로 계속 유지하겠다는 의미를 가지고 있다. 이때 입력이란 두 번째 인자에 할당된 값이며 출력이란 `chain` 함수가 평가되어 반환되는 결과를 의미한다. 첫 번째 인자는 체인 함수의 특성을 가진 다양한 함수를 만들어내기 위해서 설정하는 함수를 넣으며 세팅하는 함수에 따라 다양한 특성의 체인 함수가 만들어진다. 이런 체인 함수를 만들기 위해서 첫 번째 함수는 모나드 연산이 가능한 함수가 위치해야 한다. 모나드 연산이 가능하다는 것은 함수의 입력과 출력이 모나드 연산을 하기 위한 연산자들에 대해 수학적으로 닫혀있는 상태이며 수학적으로 닫혀 있는 값들이 존재하는 집합의 부분집합의 값이 함수의 입력과 출력이 된다는 의미이다.

- `chain(f, g)(x)`가 `f(g(x), x)`와 동등하다는 것은 `g(x)`의 결과는 `x`라는 값이 존재할 수 있는 집합에 포함될 수 있는 값이어야 한다는 것을 의미한다. 곧 `x` 집합의 부분집합이 `g(x)`가 이루는 값이 된다. 수식으로 보면 `f(g([x1, x2, x3 ...]), [x1, x2, x3 ...])`으로 `g([x1, x2, x3 ...])`의 값이 `[x1, x2, x3 ...]`에 포함될 수 있는 값이라는 것이고 이것은 `g([x1, x2, x3 ...])`와 `[x1, x2, x3 ...]`가 동일한 타입의 모나드에 해당한다는 것을 의미한다. 뒤에 나오는 표현식 `(a → m b)`의 `m b`와 `chain` 함수의 최종 평가값 `m b`는 동일한 유형의 집합 내의 값이 되므로 모나드이지만 집합의 원소가 다를 수 있는 의미이다.

- 어떤 모나드 유형의 값이 존재하고 해당 모나드의 부분집합에 해당하는 모나드 연산의 대상을 만드는 함수(`g`)를 정의한 뒤 모나드와 모나드의 부분집합의 연산(`f`)을 하기 위한 함수라고 보면된다. `g`는 부분집합을 만드는 함수이고 `f`는 부분집합과 원본간의 연산을 통해 부분집합을 만드는 것이라고 보면 된다.

## 문법

```
R.chain(fn, list): Array
```

> `fn`: The function to map with
- `fn`: 매핑할 함수
> `list`: The list to map over
- `list`: 매핑할 목록
> Returns Array The result of flat-mapping `list` with `fn`
- 배열을 반환한다. 이 배열은 `list`에 `fn`을 flat-mapping으로 적용한 결과이다.

## 표현

```
Chain m => (a → m b) → m a → m b
```

- `Chain m => ` 여기서 `m`은 모나드를 의미한다. `m b`는 `b`는 모나드로서 활용되는 값이라는 것이며, `m a`는 `a`는 모나드로서 활용되는 값이라는 의미이다.
- 자바스크립트와 `RamdaJS`에서 사용되는 모나드의 형태는 리스트의 형태이므로 일반적으로 연관 배열이 아닌 값이 나열된 배열을 받지만, 사양상 모나드 형식을 만족하는 어떤 대상이라도 올 수 있지만 리스트와 함수로 제한되어 쓰이는 것으로 보인다. 자바스크립트에서는 리스트 뿐만이 아니라 순수함수의 합성을 가능하게 하는 함수도 모나드이다. 만약 주어진 값이 리스트 형식이라면 `m a`와 `m b`도 모나드 연산을 이룰 수 있어야 하므로 리스트 형식이어야 하며, 만약 주어진 값이 함수라면 `m a`와 `m b`도 함수의 합성 연산을 할 수 있는 모나드인 함수의 형태여야 한다.
- `(a → m b)`: 첫 번째 인자로 인자를 하나 받아 어떤 모나드 값을 반환하는 함수를 받는다는 의미이다.
- `→ m a →`: 두 번째 인자로도 모나드를 받는다. 이 때, 리스트를 받는 경우와 함수를 받는 경우를 생각해 볼 수 있다.
- `→ m b`: 두 번째 인자로 `m a`로 리스트를 받게 되면 `(a → m b)`에 의해 반환 되는 대상도 리스트에 해당한다. 그러나 두 번째 인자로 함수를 받게 되면 반환 되는 대상도 함수를 반환하게 된다.
- 최종적으로 함수를 반환했을 때는 함수 자체로는 결과값을 얻는데 이용하지 않으므로 해당 함수를 평가하기 위해서 반환된 함수 `m b`는 추가적으로 인자를 받아 함수를 평가하도록 한다.

## 예제

```js
const duplicate = n => [n, n];
R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
```

- `R.chain(duplicate, [1, 2, 3])`는 첫 번째 인자로 함수, 두 번째 인자로 리스트를 받았다. 이 경우 `chain` 함수는 `map`함수의 방식으로 `duplicate` 함수에 리스트의 각 원소를 전달하여 실행한 결과를 `duplicate(1)`, `duplicate(2)`, `duplicate(3)`으로 가지며 이 결과는 `[1,1]`, `[2,2]`, `[3,3]`이 된다. `chain`은 각각의 결과를 연결하고 배열의 중첩을 제거한 결과를 반환하므로 `[1, 1, 2, 2, 3, 3]`을 반환하게 된다.

```js
R.chain(R.append, R.head)([1, 2, 3]); //=> [1, 2, 3, 1]
```

- `R.chain(R.append, R.head)([1, 2, 3])`는 첫 번째 인자로 함수, 두 번째 인자로도 함수를 받았다. 두 번째 인자로 리스트를 받았을 경우에는 첫 번째 인자로 받은 함수에 리스트의 각 원소를 할당했으나 함수는 리스트가 아니므로 원소를 갖지 못한다. 그래서 두 번째 함수를 첫 번째 함수의 인자에 그대로 전달한다. 첫 번째 함수를 f, 두 번째 함수를 g, 두 번째 인자가 함수가 아닌 리스트의 경우 리스트의 원소를 `Xn(x1, x2, x3 ...)`라고 했을 때, 두 번째 인자가 리스트의 경우는 `f(x1)`, `f(x2)`, `f(x3)`를 연결한 결과가 되었던 반면, 두 번째 인자가 함수인 경우는 `f(g(x), x)`의 원칙에 따라 `R.append(R.head(x), x)`가 된다. 이 반환된 함수에 리스트 인자를 할당하여 `R.append(R.head(x), x)`이 되므로 `R.append(R.head([1,2,3]), [1,2,3])`가 된다. 따라서 결과 값은 주어진 리스트에서 첫 번째 원소를 뽑는 `R.head([1,2,3])`에 의해 `1`을 반환, `R.append(1, [1,2,3])`에 따라 `[1,2,3,1]`를 반환한다.
- 이 때, `R.head([1,2,3])`의 결과 값은 배열 안에 든 값이 아니라 모나드가 아니잖아라고 생각할 수 있다. `R.append`란 연산은 배열에 원소를 하나 더 넣는 것이다. 원소가 될 수 있는 유형과 원소의 집합이 되는 배열간의 연산을 통해서 배열 안에 원소를 하나 더 추가하는 사양을 가진다. 배열이 아니더라도 하나의 값은 하나의 원소가 되기 때문에 모나드 사양을 만족한다고 할 수 있다.

## References
- https://ramdajs.com/docs/#chain
- https://github.com/ramda/ramda/blob/master/test/chain.js
- https://github.com/ramda/types/blob/develop/types/chain.d.ts
- https://github.com/fantasyland/fantasy-land#chain
- https://stackoverflow.com/questions/45786580/ramda-chain-usage
