# RamdaJS에 관해서

## 프로그래밍 패러다임

과거의 함수형 프로그래밍은 데이터를 가공하기 위해서 함수형 프로그래밍을 통해서 우아한 함수의 합성 기술을 강조하는 경향이 있었다.

하지만 최근에는 타입시스템과 함수형 프로그래밍의 기법을 조합하여 타입 안정성을 위한 구조적 코딩의 도구로서 활용하는 경향이 커졌다.

## 데이터 조작 VS 구조적 제어

하스켈, 스칼라의 cats, scalaZ, ZIO 등의 라이브러리들은 구조적 제어의 툴을 제공한다. 이들은 타입시스템과 함수형 프로그래밍을 사용해서 타입 안전한 함수를 합성을 할 수 있는 구조와 사이드이펙트(I/O, ERROR 등을) 처리할 때 함수형 프로그래밍을 사용하기 좋게 구조적인 틀을 제공한다. 타입스크립트에서는 EffectTS가 이러한 역할을 하는 툴에 해당한다.

이와 달리, 엘릭서, 클로저 등의 동적 타입 언어에서의 함수형 프로그래밍은 함수의 우아한 합성을 통한 데이터의 제어와 우아한 데이터 파이프라인의 생성에 초점을 맞춘다. RamdaJS는 이런 류에 속한다.

## DATA-last

클로저, 엘릭서의 언어에서 착안한 프로그래밍 기법이 타입이 없던 자바스크립트에 도입이 되었고, RamdaJS는 클로저 언어의 영향을 받아 함수를 우아하게 합성할 수 있는 data-last 방식 코딩 스타일을 제안했다.

pipe, compose 함수를 사용할 때, 인자로 전달하는 함수는 하나의 데이터만 인자로 받는 함수여야 하는데, data-last 방식을 사용하면 함수의 인자를 커링으로 채운 후, 하나의 인자만 받는 함수로 만드는 것이 쉽고, 함수의 데이터를 받는 인자를 마지막에 할당하지 않는 방식을 사용하기 위해서는 인자의 순서를 변경하는 등의 추가 공정이 들어가게 되었다.

그래서 함수를 우아하게 합성하고, 데이터를 정교하게 가공하기 위한 목적의 자바스크립트에서의 함수형 프로그래밍은 data-last 방식을 채용하게 되었다.

### DATA-first

타입스크립트는 첫 번째 인자로 전달된 데이터의 타입을 기반으로, 이후에 오는 인자(함수 등)의 타입을 추론하는 방식을 사용한다.

타입스크립트의 등장 이후로는 타입을 구체화하기 위한 전략으로 데이터를 처음에 두는 DATA-first의 코딩 스타일이 타입스크립트와 궁합이 좋아지면서 DATA-last 패러다임은 서서히 몰락의 길을 걷게 되었다.

## 지연평가

함수를 합성하면, 실행할 수 있는 함수가 생성되는데, 이 함수는 데이터를 받아서 실행될 대상이므로 호출되지 않은 함수이다.

일반적인 프로그래밍에서라면 데이터에 함수를 하나씩 적용하고 그 결과에 또 함수를 적용해야 하지만, 함수의 합성을 이용하면 데이터가 주어지지 않은 상태에서 로직을 결합할 수 있다는 장점이 있다.

함수를 합성하여 새로운 함수를 만들면 필요할 때 조합된 로직의 함수를 개별로 호출하거나, 다른 로직을 구성할 때 함수를 건내주어 새로운 합성 함수를 만드는 재료로 사용할 수 있다. 함수의 합성은 데이터(상태) 없이 로직의 결합을 통한 추상화를 할 수 있는 장점이 있다.

하지만 합성하고 조합할 때의 코드에서 에러나 버그가 발생하는 것이 아니라, 합성된 함수에서 에러나 버그가 발생하게 되어, 함수를 조합할 때 어떤 함수 부분에서 실행되었는지 바로 알 수 없다는 문제점이 있다. 합성된 함수의 전체 로직의 흐름을 이해하여 문제가 발생한 부분을 특정하던지, 값의 변화 과정을 추적할 수 있는 사이드이펙트를 처리하기 위한 로깅 함수를 함께 합성해 디버깅을 수월하게 만들어야 한다는 문제가 있다.

## 함수 합성의 장단점

수학에서 작은 증명된 공식을 조합하는 것으로 더 큰 증명을 할 수 있는 것과 같이, 함수형 프로그래밍에서도 작은 함수의 조합을 통해서 로직을 쌓는 것으로 견고한 로직을 쌓아나갈 수 있다는 장점이 있다.

자바스크립트는 동적 타입 언어라는 약점이 있어, 거대한 함수의 조합 로직이 있는 코드를 통과할 때 일부 엣지 케이스에 대해서 잘못된 값이 생성될 수 있다는 문제점이 있다.

이를 보완하기 위해 런타임 타입 체크 도구(Zod、Ajv、Yup、Joi、Valibot)를 사용하거나, composeWith, pipeWith 등의 함수로 파이프의 다음 함수로 결과값을 전달할 값과 에러 두 양상의 값을 전달하여 (Result 패턴) 엣지 케이스를 처리하여 함수를 합성할 수 있다.

함수를 합성하면 에러가 발생했을 때, 어디서 에러가 발생했는지 알기 어렵다는 문제가 있다. 그래서 너무 많은 거대한 함수의 합성으로 함수를 생성하기 보다는 적은 양의 함수만 합성하여 런타임 타입 체크 도구로 호출 전후의 값을 검사하거나, `composeWith`, `pipeWith`와 `tap` 함수를 조합하여 허락된 값이 아닌 경우에는 로깅(console.warn 등의 함수)을 통해 런타임에서 어떤 부분에서 문제가 발생했는지 확인할 수 있도록 하는 방법을 사용해야 한다.

긴 파이프라인을 만들 때는, 이해 가능한 단위의 함수를 함수의 합성으로 여럿 만들어, 파이프에 나열하여 흐름을 이해할 수 있도록 만드는 편이 좋다. 그리고 합성된 함수에 대한 테스트 코드를 작성하는 것이 추천된다.

## 추상화

복잡한 로직을 함수형으로 구현할 때, 성급하게 높은 수준의 추상화를 시도하기보다는 작은 단위의 함수 조합부터 시작해야 한다.

객체지향에서 명확한 메서드명과 시그니처를 통해 의도를 드러내듯이, 함수형 프로그래밍에서도 의도와 시그니처가 분명한 중간 단위의 함수를 먼저 정의하고, 이를 다시 조립하는 방식으로 가독성 높은 코드를 작성한다.

이때, JSDoc이나 가능하다면 명시적 타입 선언을 적극 활용하여 함수의 입력과 출력을 명확히 정의하여, 로직을 쉽게 이해할 수 있도록 한다.

또한, 이렇게 조합된 함수는 외부 상태에 의존하지 않는 순수 함수이므로, 복잡한 모킹 없이 입력과 출력만 검증하면 되는 수월한 테스트 환경을 제공한다.

## 함수형 라이브러리를 사용하는 이유

함수의 조합을 위해서 직접 함수를 만드는 것보다 가능하면 기존 라이브러리의 함수를 사용하고 이를 조합하는 방식으로 만드는 것이 좋다. 재사용할 수 있고 단위 테스트 검증이 되어 있기 때문에 로직을 합성하는데서 발생하는 로직 문제, 처리할 수 없는 데이터의 전달이 아니라면 문제가 발생하지 않는다. 로직이 잘못되어 있거나 처리할 수 없는 데이터의 전달만 잘 확인하면 된다.

### IDE의 자동완성

라이브러리를 사용하면, 매개 변수에 어떤 값을 요구하는지 설명하는 주석도 포함되어 있어서, 함수를 사용할 때 JSDoc의 주석 메시지를 IDE가 표기하는 것을 통해 함수에 어떤 값을 전달해야 하는지 쉽게 알 수 있다는 장점이 있다. 커스텀으로 함수를 만들게 되면 주석의 누락으로 매개변수에 어떤 값을 넣어야 할지 알 수 없는 경우도 생길 수 있고, 주석이 업데이트 되지 않을 수 있기 때문에 오랜 세월 이러한 편의성을 위해 노력해 온 라이브러리를 사용하는 편이 좋다.

### 잘 갖춰진 문서

잘 갖춰진 문서와 예제를 통해서 함수를 사용하는 방법을 확인하고 쉽게 학습할 수 있다는 장점이 있다.

## 엄격한 함수형 프로그래밍의 문제

순수 함수형 프로그래밍 언어 하스켈에서 시작해 이 프로그래밍 기법을 멀티 패러타임 언어에 적용하여 사용하던 스칼라 등을 사용하던 언어의 유저들은 엄격한 타입 레벨의 무결성을 위한 프로그래밍 기법을 만들어왔다. 자바스크립트에 타입이 추가되어 이런 프로그래밍 방식을 어느 정도 도입할 수 있게 되자, 엄격한 함수형 프로그래밍 방식을 사용한 코드를 만들 수 있도록 라이브러리를 만들어 왔다. 하지만 이런 라이브러리는 사용 방법을 익히기 어려우며, 특정 방식의 코딩 방식을 강요한다는 문제점이 있다.

### 함수형 추상화는 생각보다 쉽지 않다.

함수형 프로그래밍은 수학적인 추상화를 요구한다. 하지만 수학적 추상화는 여러 계산 시나리오들을 시도해 보고 패턴을 적립한 후에야 추상화를 할 수 있는 경우가 많다. 또한 업무 환경의 로직은 적절한 도메인 패턴이 형성되기 까지 여러 시행착오를 겪는데, 이 때마다 추상화된 로직을 바꾸는 것을 오버헤드가 될 수 있다. 부적절한 추상화는 객체지향이든 함수형이든 어느 쪽이나 이해하기 쉽지 않다는 문제점이 있다.

### 회사는 함수형 프로그래밍을 좋아하지 않는다.

회사의 업무 시간은 제한적이며, 제한된 시간 안에 많은 일을 해야 한다. 이를 위해서는 필요한 학습의 양과 코드를 수정하고 개선하는 일이 일과 시간 안에 끝낼 수 있어야 한다. 기본적으로 절차지향의 코드를 작성할 수 있어야 하며, 개개인의 역량에 따라 좀 더 나은 추상화를 할 수 있도록 만들어야 여러 사람들이 제한된 시간 안에 문제를 해결할 수 있다. 개인 공부, 야근을 통해서 문제를 해결하고 성장할 수 있을지는 모르지만, 좋은 회사라면 기본적으로 업무 시간안에 학습하고 익히고 적용하고 개발할 수 있는 쉬운 개발을 할 수 있는 문화를 만들고 싶어 할 것이다.

### 실력자는 쉽게 구인할 수 없다.

회사의 인재는 항상 뛰어난 능력의 사람만 있는 것은 아니다. 와 이런 사람도 우리회사에 들어오는구나를 실감할 수 있는 회사는 생각 보다 적다. 실력이 부족한 사람을 고용해서 성과를 만들 수 있어야 하는데 함수형 프로그래밍은 교육에만 많은 시간이 필요하고, 각각의 개개인이 함수형 프로그래밍에 의지와 관심이 있어야 한다. 또한 회사가 채용할 때 구인을 쉽게 할 수 있어야 한다. 일반적인 프로그래밍을 했던 사람 평범한 프로그래밍을 했던 사람, 잘 알려진 프로그래밍을 했던 사람은 채용하기 쉬운 반면, 함수형 프로그래밍에 익숙한 사람은 채용하기 어렵다는 문제점이 있다.

### 자바스크립트 생태계

자바스크립트 생태계는 어떤 프레임워크를 사용하기 보다는 파편화된 라이브러리를 조합해서 사용하는 경우가 많다. 각종 툴들의 인터페이스가 다른데, 엄격한 함수형 프로그래밍을 위해서는 이들 툴들을 함수형 프로그래밍을 할 수 있도록 별도의 추상화 작업을 요구한다. 추상화를 위한 비용이 발생하고, 여러 사람이 즐겁게 개발하기 보다는 소수의 사람의 지적 유희를 위한 일이 되고 나머지 사람들에게는 지루한 작업을 부담하는 일이 될 수 있다.

### 도메인에 맞는 적절한 선택

엄격한 함수형 프로그래밍은 개발이 느리더라도 안정성과 엄격함이 중요시 되는 분야에 적합하다. 대부분의 비즈니스는 적당한 속도의 구현과 사업팀의 구성원들의 모호한 아이디어를 구현과 피드백을 거쳐서 출시되는 경우가 많고, 이런 개발 검증의 과정은 완벽하지는 않지만 조금씩 개선하면서 문제점을 보완하고 수정하는 방향으로 진행된다. 엄격한 함수형 언어는 안정성을 위해서 상대적으로 학습에도 느리고, 코드를 개발하는데도 느린 개발 속도를 채택하는 것으로 수학학이나 수학에 가까운 이론적인 검증이 완료된 개념을 코드에 적용하는 것으로 이러한 기술을 사용하는데 적합한 도메인이 아니라 일반적인 도메인에서는 적합한 선택이 아닐 수도 있다.

## 왜 RamdaJS인가?

- [@types/ramda](https://github.com/ramda/types)의 등장으로 타입스크립트에서도 사용할 수 있게 되었다.

- 잘 설명된 [공식 문서](https://ramdajs.com/)가 존재하고, 각종 스펙과 사용법을 배우기 쉽게 만들어 두었다.

- 함수형 프로그래밍을 할 수도 있지만, 유틸리티 라이브러리로 사용가능한 함수들을 모아 두었다. 함수형 프로그래밍 기법에 대한 엄격한 고집이 없기 때문에 기존의 다양한 라이브러리의 툴들과도 섞어서 사용할 수 있다.

- 경우에 따라 함수형 프로그래밍이 더 간결한 언어적 표현, 더 이해하기 쉬운 코드가 될 수 있다. 멀티 패러다임 언어인 자바스크립트에서 필요에 따라 함수형 프로그래밍을 도입하기 편리하다.

- 자바스크립트의 기본 문법과 기능들을 레핑한 함수들이 많기 때문에 자바스크립트 지식만으로도 Ramda의 함수들을 해석할 수 있고, Ramda의 함수를 익히는 것으로 자바스크립트의 각종 문법에 대한 지식이 늘 수 있다는 장점이 있다.

- 다른 함수형 유틸리티 라이브러리와 달리 함수를 합성을 통해 새로운 함수를 생성하는 방식에 초점을 맞추고 있고 data-last의 인자를 받기 때문에 파이프 함수 등의 함수형 기법을 적용할 때 좀 더 깔끔하게 코드를 작성할 수 있는 이점이 있다.

## 단순한 함수의 존재이유

### 연산자가 있는 기능이 함수로 제공되는 의아함

함수형 자바스크립트를 보면 굉장히 많은 함수가 존재한다. 그 중에는 `add`, `subtract`, `sum`, `mean`, `divide` 등과 같은 기본적인 연산을 위한 함수도 존재한다. 이들 연산은 프로그래밍 언어의 `+`, `-`, `*`, `/`을 조합한 간단한 수식 또는 간단하게 함수로 만들 수 있는데도 불구하고 미리 만들어져 제공하고 있다.

이런 함수의 존재를 일일이 기억하고 찾아서 적용하기 보다는 그냥 그 상횡에 필요한 함수를 정의하는 편이 더 간단할 수 있으며, 간단한 수식은 함수를 쓰기 보다는 필요한 수치의 조합으로 만드는 편이 훨씬 더 간결한 코드를 만들 수 있음에도 불구하고 기본적인 함수들을 제공한다.

### 어차피 함수로 만들어야 한다.

이는 자바스크립트가 함수형 언어가 아니기 때문에 연산자의 입력과 처리가 함수에 인자를 넣고 그 결과값을 반환하는 방식과는 다르기 때문인 이유가 있는데 함수형 프로그래밍으로 다양한 함수를 조합해서 논리를 만들기 위해서는 아무리 단순한 연산이라도 함수로 만들어야 하기 때문이다. 그리고 필요에 따라 커링 처리도 해야 하므로 코드가 조금 길어진다. 어차피 연산자를 그대로 쓰는 것이 아니라 함수로 만들어 쓸 것이라면 기존에 함수를 만들어 둬서 간결하게 쓰는 편이 낫다.

### 일관된 시그니처

간단한 함수라도 함수 별로 사양이 달라질 수 있다. 예를 들어 나누기를 할 때 제수와 피젯수를 첫 번째 인자로 할지 두 번째 인자로 할지 다르게 정의할 가능성이 있다. 누구나 인자의 순서를 동일하게 바라볼 수 있을 만큼 잘 알려진 개념이라면 커스텀으로 정의를 해도 인자의 순서가 달라지지 않겠지만, 그렇지 않다면 인자의 순서가 사람마다 달라 함수를 읽을 때 뭐가 뭐에 해당하는지 함수의 사양을 일일이 확인해야 하는 문제가 생길 수 있다.

함수형 프로그래밍에서 가독성을 향상시키기 위해서는 인자의 매개변수의 순서와 반환 값 등의 사양에 대한 혼동이 없어야 하는데 이를 위해서는 간단한 기능이라도 라이브러리 수준에서 제공해서 동일한 기능의 사양이 달라질 가능성을 최소한으로 하는 것이 중요하다.

## 동적 언어의 함수형 프로그래밍

정적 언어의 함수형 프로그래밍은 타입 안정성에 초점을 맞추고, 일관된 패턴을 통해서 코드를 전개할 수 있는 방향을 추구한다. 하지만, 동적 언어의 함수형 프로그래밍은 이와 달리 함수의 합성이나 도메인에 맞는 적절한 기능을 함수형 프로그래밍으로 생성하는데 초점을 맞춘다.

